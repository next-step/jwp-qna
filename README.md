# JPA HandsOn

## 🚀 1단계 - 엔티티 매핑

### Goal

QnA 서비스를 만들어가면서 JPA로 실제 도메인 모델을 어떻게 구성하고 객체와 테이블을 어떻게 매핑해야 하는지 알아본다.

### Requirements

* 아래의 DDL(Data Definition Language)을 보고 유추하여 엔티티 클래스와 리포지토리 클래스를 작성해 본다.
* @DataJpaTest를 사용하여 학습 테스트를 해 본다.

```sql
create table answer
(
    id          bigint generated by default as identity,
    contents    clob,
    created_at  timestamp not null,
    deleted     boolean   not null,
    question_id bigint,
    updated_at  timestamp,
    writer_id   bigint,
    primary key (id)
)

create table delete_history
(
    id            bigint generated by default as identity,
    content_id    bigint,
    content_type  varchar(255),
    create_date   timestamp,
    deleted_by_id bigint,
    primary key (id)
)

create table question
(
    id         bigint generated by default as identity,
    contents   clob,
    created_at timestamp    not null,
    deleted    boolean      not null,
    title      varchar(100) not null,
    updated_at timestamp,
    writer_id  bigint,
    primary key (id)
)

create table user
(
    id         bigint generated by default as identity,
    created_at timestamp   not null,
    email      varchar(50),
    name       varchar(20) not null,
    password   varchar(20) not null,
    updated_at timestamp,
    user_id    varchar(20) not null,
    primary key (id)
)

alter table user
    add constraint UK_a3imlf41l37utmxiquukk8ajc unique (user_id)


```

### TODO
- [x] JPA Auditing Entity
- [x] Enable JPA Audit in Application 
- [x] Answer Entity
- [x] Answer Test (CRUD)
- [x] DeleteHistory Entity
- [ ] ~~DeleteHistory Test(CRUD)~~
- [x] Question Entity
- [x] Question Test(CRUD)
- [x] User Entity
	- [x] 스키마에 맞게 어노테이션 추가
	- [x] 불필요한 setter 삭제
	- [x] equals / hashCode 추가
		- [x] core fields = id, userId
- [x] User Entity Test (CRUD)

### Hints

Spring Data JPA 사용 시 아래 옵션은 동작 쿼리를 로그로 확인할 수 있게 해준다.

```
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.show-sql=true
```

## 🚀 2단계 - 연관 관계 매핑

### Requirement

객체의 참조와 테이블의 외래 키를 매핑해서, 객체에서는 참조를 사용하고 테이블에서는 외래 키를 사용할 수 있도록 한다.

### Hints

아래의 DDL을 보고 유추한다.

```sql
alter table answer
    add constraint fk_answer_to_question
        foreign key (question_id)
            references question

alter table answer
    add constraint fk_answer_writer
        foreign key (writer_id)
            references user

alter table delete_history
    add constraint fk_delete_history_to_user
        foreign key (deleted_by_id)
            references user

alter table question
    add constraint fk_question_writer
        foreign key (writer_id)
            references user

```

### TODO
- [x] Apply Step1 Feedback
	- [x] Renameing TestClass Names to XXRepoTest
- [x] Question entity 수정
- [x] QuestionRepositoryTest수정
- [x] DeleteHistory Entity수정
- [x] Answer entity 수정
- [x] Answer Repository  Test수정
	- [x] 새로 추가한 메서드두 테스트
- [x] User Repository Test수정
- [x] (Optional) 필요하다면 해당 ServiceCode , Test수정
- [x] (Optional) FK 붙이기

- [x] TestFixture고치기
	- [x] JPA 테스트에서 테스트 대상을 static으로 만들어놓고 재사용하게 되면 여러가지 문제가 될 것을 고려하여,  컨텍스트 격리를 고려한 테스트 픽스처 작성

- [x] QnA서비스수정
- [x] QnA서비스테스트가 영향없는 것 확인

- [x] 더이상 쓰이지 않는 코드들 + 테스트 코드 삭제(아이디관련한 메서드들)

- [x] DB 스키마는 변경 안된 것 확인

---
### 고려사항
- [x] 먼저 단방향으로 설계 끝내기
- LAZY의 이점과, 고려할점 을 확인하기까지는,  LAZY걸지 않고 설계하기.
- 굳이 양방향으로 만들 필요 있나 모든 설계 끝나고 재 확인
	- 필요하다면 편의 메서드 만들기 for Testing
	- 무한루프 가능성 체크하기(toString(), lombok, JSON생성)

---
## 🚀 3단계 - 질문 삭제하기 리팩터링
### 기능 요구사항
- 질문 삭제 OK 케이스 :
	- 답변이 없는 경우
	- 로그인 사용자와 질문한 사람이 같은 경우
	- 질문자와 답변글의 모든답변자 같은경우
- 질문 삭제 NG 케이스 :
	- 로그인 사용자와 질문한 사람이 다른 경우.
	- 질문자와 답변글의 모든 답변자 중, 한 사람이라도 다른 유저가 쓴 답변이 존재하는 경우
- 질문 삭제시 Behavior :
	- 질문 Soft-delete (데이터의 상태를 삭제 상태(deleted - boolean type)로 변경)
	- 답변 또한 soft delete
	- 질문과 답변 삭제 이력에 대한 정보를 DeleteHistory insert
### 프로그래밍 요구사항
- qna.service.QnaService의 deleteQuestion()는 앞의 질문 삭제 기능을 구현한 코드이다. 이 메소드는 단위 테스트하기 어려운 코드와 단위 테스트 가능한 코드가 섞여 있다.
- 단위 테스트하기 어려운 코드와 단위 테스트 가능한 코드를 분리해 단위 테스트 가능한 코드 에 대해 단위 테스트를 구현한다.
```java
public class QnAService {
    public void deleteQuestion(User loginUser, long questionId) throws CannotDeleteException {
        Question question = findQuestionById(questionId);
        if (!question.isOwner(loginUser)) {
            throw new CannotDeleteException("질문을 삭제할 권한이 없습니다.");
        }

        List<Answer> answers = question.getAnswers();
        for (Answer answer : answers) {
            if (!answer.isOwner(loginUser)) {
                throw new CannotDeleteException("다른 사람이 쓴 답변이 있어 삭제할 수 없습니다.");
            }
        }

        List<DeleteHistory> deleteHistories = new ArrayList<>();
        question.setDeleted(true);
        deleteHistories.add(new DeleteHistory(ContentType.QUESTION, questionId, question.getWriter(), LocalDateTime.now()));
        for (Answer answer : answers) {
            answer.setDeleted(true);
            deleteHistories.add(new DeleteHistory(ContentType.ANSWER, answer.getId(), answer.getWriter(), LocalDateTime.now()));
        }
        deleteHistoryService.saveAll(deleteHistories);
    }
}
```
### 힌트
- 객체의 상태 데이터를 꺼내지(get)말고 메시지를 보낸다.
- 규칙 8: 일급 콜렉션을 쓴다.
	- Question의 List를 일급 콜렉션으로 구현해 본다.
- 규칙 7: 3개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.
	- 인스턴스 변수의 수를 줄이기 위해 도전한다.
- 테스트하기 쉬운 부분과 테스트하기 어려운 부분을 분리해 테스트 가능한 부분만 단위테스트한다.

### TODO
- [x] Apply Previous step feedback
- [x] QnA서비스 중 테스트하기 어려운 부분 Question 로직으로 분리
- [x] Question delete로직 구현
- [x] Answer delete로직 구현
- [x] Answers 1급 컬렉션 작성
- [x] QnA서비스 영향 없는지 확인
- [x] Question Test 작성
- [x] Answer Test 작성
- [x] Answers Test 작성
- [x] 무한루프 걸리는 곳 있는지 확인(toString(), 생성자, lombok)
- [x] Double check Answers JPA annotations

---
### Note
* JPA는, ID기반.
* JPA는, Dynamic Proxy기반?으로 생성하기에, default constructor필요.
* CLOB = Character Large OBject
* @DataJpaTest
	* For DB layer slicing test
	* JPA와 관련된 빈들만 초기화 해준다
	* @Tx가 걸려있어, 테스트 끝날 때마다 롤백 지원
* JPA repo save()한 값을 써라.
	* Use the returned instance for further operations as the save operation might have changed the entity instance completely.
* @CreatedDate, You dont have to set value manually .
* ErrorMessage는 Enum으로 관리도 가능
* 양방향 관계설정시, 무한루프 걸리지 않나 더블 체크 필요(toString(), 생성자, 편의메서드)

### QnA

##### Q: JPA가 사용하는 Proxy기술은? GCLIB? Dynamic Proxy?

##### Q: Generation Type attributes?

##### Fixed : 무조건 다 @Column속성 지정해야 하나?
->  NO
```java
/**
 * Specifies the mapped column for a persistent property or field.
 * If no <code>Column</code> annotation is specified, the default values apply.
 *
 * <blockquote><pre>
 *    Example 1:
 *
 *    &#064;Column(name="DESC", nullable=false, length=512)
 *    public String getDescription() { return description; }
 *
 *    Example 2:
 *
 *    &#064;Column(name="DESC",
 *            columnDefinition="CLOB NOT NULL",
 *            table="EMP_DETAIL")
 *    &#064;Lob
 *    public String getDescription() { return description; }
 *
 *    Example 3:
 *
 *    &#064;Column(name="ORDER_COST", updatable=false, precision=12, scale=2)
 *    public BigDecimal getCost() { return cost; }
 *
 * </pre></blockquote>
 *
 *
 * @since 1.0
 */ 
```

##### Fixed : sql.TimeStamp vs Date vs LocalDateTime?
- Data : 모호한 설계 와 가변성/ 시간을 MS초로 표현 /1900년 시작 Offset / 0으로 시작하는 달 인덱스 / 중앙유럽시간
- LocalDateTime (from Java8) : 불변/ NS까지 표현가능 /. No Offset / 1로 시작하는 달 인덱스
- TimeStamp : NS까지 표현 가능

##### Q: How to set Unique Constraints in JPA?
- Unique key is a set of single or multiple columns of a table that uniquely identify a record in a database table
- JPA allows us to define unique constraints in our code using 
- Column Constraints -> @Column(unique=true) 
- Table Constraints -> @UniqueConstraint. 
- Refer : https://www.baeldung.com/jpa-unique-constraints

##### Fixed : JPA Buddy plug in으로 무엇이 가능한지?
- Refer : https://www.jpa-buddy.com/?utm_source=baeldung&utm_medium=display&utm_campaign=npi

##### Q : 	BaseTimeEntity를 상속한 엔티티클래스에서, Super 생성자를 부르지 않는데,  어떻게 컴파일이 되는건지? @MappedSuperclass 동작 확인

##### Fixed : Entity의 ID 필드를 논리 동치성(동등성) 계산시 포함해야 하나?
- 만약 포함한다면, DB보존 전후로, equals()를 통한 동등성 계산에 실패하게 된다.
	- 개체 생성시 ID가 존재 하지 않는 개체는 , JPA통해 save후에는 ID가 존재하게 되므로.
	- 결론 : PK를 가지고 구현. 이 경우 영속화되기 전의 객체는  equals, hashcode 가 제대로 동작하지 않을 가능성이 있지만, 컨벤션을 통해 보완하기.

##### Q : save전후로 참조 요소가 달라지는건, ID속성이 NULL일때만 아니었나? 


##### Q : LAZY의 성능 이점 이외의 Pros과 Consideration
- LazyInitializationException, N+1 query, fetch join, @BatchSize, entity graph 키워드를 순서대로 찾아서 학습
- 고려Case : LAZY로 연관관계가 설정된 객체를, 트랜잭션 범위 밖(커넥션이 없는 상태)에서 toString 이 호출할 경우 생기는 문제

##### Fixed : Can’t connect to H2 v2.1.214 from IntelliJ
- Cause : IntelliJ tries to fetch the table names, using the statement
SELECT CATALOG_NAME FROM INFORMATION_SCHEMA.CATALOGS
which is only supported for H2 1.4.200 and older.
- Solution : As workaround to use IntelliJ with newer H2 drivers the old behavior can be activated by adding OLD_INFORMATION_SCHEMA=TRUE to the connect string.
- Refer : https://github.com/JetBrains/jetbrains_guide/issues/215

##### Fixed : 42001 Syntax error when create table user
- Cause : Needed to add Identifier
- ASIS : ```create table user```
- TOBE : ```create table "USER"```


